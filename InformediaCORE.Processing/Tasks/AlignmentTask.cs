using System;
using System.IO;

using InformediaCORE.Common;
using InformediaCORE.Common.Database;
using InformediaCORE.Processing.Gentle;

namespace InformediaCORE.Processing.Tasks
{
    /// <summary>
    /// Aligns the transcript to the video.
    /// </summary>
    /// <remarks>
    /// NEW FOR 2020!! GENTLE FORCED ALIGNER
    /// </remarks>
    public class AlignmentTask : AbstractTask
    {
        private string _outputFile;

        /// <summary>
        /// The name of the output file generated by this process.
        /// </summary>
        private string OutputFile
        {
            get
            {                
                if (String.IsNullOrEmpty(_outputFile))
                {
                    _outputFile = Path.Combine(DataPath, $"{SegmentID}.alignment.json");
                }
                return _outputFile;
            }
        }

        #region Constructors
        /// <summary>
        /// Instantiates an instance of the AlignmentTask class from the given segment id.
        /// </summary>
        /// <param name="segmentID">A valid segment id.</param>
        /// <param name="condition">Specifies whether the task should be run regardless of previous run condition.</param>
        public AlignmentTask(int segmentID, RunConditionValue condition = RunConditionValue.AsNeeded) : base(segmentID, condition) { }

        /// <summary>
        /// Instantiates an instance of the AlignmentTask class from the given segment name.
        /// </summary>
        /// <param name="segmentName">A valid segment name.</param>
        /// <param name="condition">Specifies whether the task should be run regardless of previous run condition.</param>
        public AlignmentTask(string segmentName, RunConditionValue condition = RunConditionValue.AsNeeded) : base(segmentName, condition) { }

        /// <summary>
        /// Instantiates an instance of the AlignmentTask class from the given segment.
        /// </summary>
        /// <param name="segment">A valid segment.</param>
        /// <param name="condition">Specifies whether the task should be run regardless of previous run condition.</param>
        public AlignmentTask(Segment segment, RunConditionValue condition = RunConditionValue.AsNeeded) : base(segment, condition) { }
        #endregion Constructors

        #region Internal Overrides
        /// <summary>
        /// Checks that the necessary input requirements are met prior to running the task.
        /// </summary>
        internal override void CheckRequirements()
        {
            if (string.IsNullOrEmpty(Segment.MediaPath))
                throw new TaskRequirementsException("Required media path is null or empty.");

            if (!File.Exists(Segment.MediaPath))
                throw new TaskRequirementsException($"Could not find required input file {Segment.MediaPath}.");

            if (Segment.TranscriptText == null)
                throw new TaskRequirementsException("Transcript is null.");

            if (Segment.TranscriptText == string.Empty)
                throw new TaskRequirementsException("Transcript is empty.");
        }

        /// <summary>
        /// Purges prior forced alignment results from the file system.
        /// </summary>
        internal override void Purge()
        {
            // Only delete existing data if the run condition is Always.
            if (File.Exists(OutputFile) && RunCondition == RunConditionValue.Always)
            {
                Logger.Write("Deleting existing alignment data {0}.", OutputFile);
                File.Delete(OutputFile);
            }
        }

        /// <summary>
        /// Runs the transcript alignment task for the associated segment.
        /// </summary>
        internal override void Run()
        {
            var tmpPath = Path.GetTempPath();
            var mp4File = Path.Combine(tmpPath, Segment.SegmentName + ".mp4");
            var txtFile = Path.Combine(tmpPath, Segment.SegmentName + ".txt");

            try
            {
                // ============================================================
                // CREATE OUTPUT DIRECTORY
                if (!Directory.Exists(DataPath))
                    Directory.CreateDirectory(DataPath);

                if (!Directory.Exists(DataPath))
                    throw new TaskRunException($"Failed to create output directory {DataPath}.");

                if (File.Exists(OutputFile) && RunCondition != RunConditionValue.Always)
                {
                    Logger.Write("Keeping existing alignment data {0}.", OutputFile);
                }
                else
                {
                    // ============================================================
                    // STAGING
                    var redactedTranscript = RedactTranscript(Segment.TranscriptText);
                    if (string.IsNullOrEmpty(redactedTranscript))
                        throw new TaskRunException("Transcript contains mismatched brackets; unable to run alignment.");

                    Logger.Write("Staging video to: {0}", mp4File);
                    File.Copy(Segment.MediaPath, mp4File, true);

                    Logger.Write("Staging redacted transcript to: {0}", txtFile);
                    Utilities.WriteToFile(redactedTranscript, txtFile);

                    // ============================================================
                    // ALIGNMENT
                    Logger.Write("Starting alignment process...");
                    var alignmentResult = GentleForcedAligner.AlignTranscript(mp4File, txtFile);

                    // Restore transcript to it's original unredacted value.
                    alignmentResult.Transcript = Segment.TranscriptText;

                    // ============================================================
                    // SAVE TO DISK
                    Logger.Write("Saving output to {0}.", OutputFile);
                    var json = Newtonsoft.Json.JsonConvert.SerializeObject(alignmentResult, Newtonsoft.Json.Formatting.Indented);
                    Utilities.WriteToFile(json, OutputFile);
                }
            }
            catch
            {
                // Rethrow the exception while preserving the stack trace
                // See: https://docs.microsoft.com/en-us/visualstudio/code-quality/ca2200?view=vs-2019
                throw;
            }
            finally
            {
                // Clean up temp files.
                Logger.Write("Cleaning up temporary files.");
                File.Delete(mp4File);
                File.Delete(txtFile);
            }
        }
        #endregion Internal Overrides

        #region Helper Functions
        /// <summary>
        /// Redacts unspoken (bracketed) passages in the given transcript
        /// in preparation for forced alignement.
        /// </summary>
        /// <param name="transcript">The transcript to be redacted.</param>
        /// <returns>A redacted copy of the transcript.</returns>
        private string RedactTranscript(string transcript)
        {
            int brackets = 0;
            var charArray = transcript.ToCharArray();

            for (int i = 0; i < charArray.Length; i++)
            {
                switch (charArray[i])
                {
                    case '[':
                    case '(':
                        brackets++;
                        break;
                    case ']': 
                    case ')':
                        brackets--;
                        break;
                    default:
                        if (brackets > 0)
                        {
                            // Redact text within brackets except for spaces
                            if (charArray[i] != ' ') { charArray[i] = '-';  }
                        } 
                        break;
                }
            }

            if (brackets == 0)
            {
                return new string(charArray);
            }
            else
            {
                return null;
            }
        }
        #endregion Helper Functions
    }
}
